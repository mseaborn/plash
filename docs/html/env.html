<html><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968"><title>Chapter&#160;3.&#160;Plash's restricted execution environment</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Plash: the Principle of Least Authority shell"><link rel="up" href="index.html" title="Plash: the Principle of Least Authority shell"><link rel="prev" href="shell-scripts.html" title="Shell scripts"><link rel="next" href="env-symlinks.html" title="Symbolic links"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&#160;3.&#160;Plash's restricted execution environment</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="shell-scripts.html">Prev</a>&#160;</td><th width="60%" align="center">&#160;</th><td width="20%" align="right">&#160;<a accesskey="n" href="env-symlinks.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="env"></a>Chapter&#160;3.&#160;Plash's restricted execution environment</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="env.html#env-overview">Architecture overview</a></span></dt><dt><span class="sect1"><a href="env-symlinks.html">Symbolic links</a></span></dt><dd><dl><dt><span class="sect2"><a href="env-symlinks.html#id2473794">Semantics</a></span></dt><dt><span class="sect2"><a href="env-symlinks.html#id2473837">Implementation</a></span></dt><dt><span class="sect2"><a href="env-symlinks.html#id2473890">Remaining problems</a></span></dt></dl></dd><dt><span class="sect1"><a href="env-parent-dirs.html">Parent directories: the semantics of dot-dot using dir_stacks</a></span></dt><dt><span class="sect1"><a href="env-dir-fds.html">Directory file descriptors</a></span></dt><dt><span class="sect1"><a href="syscall-intercept.html">Why not do interception of system calls using, for example, ptrace?</a></span></dt><dt><span class="sect1"><a href="chroot-comparison.html">How does Plash compare with chroot jails?</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="env-overview"></a>Architecture overview</h2></div></div></div><p>Plash limits the ability of a process to open files by running it in a
chroot environment, under dynamically-allocated user IDs.  The chroot
environment only contains one file, an executable to exec to start the
program running in the process.</p><p>Rather than using the open() syscall to open files, the client process
sends messages to a server process.  One of the file descriptors that
the client is started with is a socket which is connected to the
server.  The environment variable PLASH_COMM_FD gives the file
descriptor number.  The server can send the client open file
descriptors across the socket in response to `open' requests (see
cmsg(3)).</p><p>The server can handle multiple connections.  If the client wishes to
fork() off another process, it first asks the server to send it
another socket for a duplicate connection.</p><p>GNU libc is re-linked so that open() etc. send requests to the server
rather than using the usual Unix system calls.  The dynamic linker
(/lib/ld.so or, equivalently, /lib/ld-linux.so.2) is similarly
re-linked.  execve() is changed so that it always invokes the dynamic
linker directly, since the chroot environment does not contain the
main executable and the kernel does not provide an fexecve() system
call.  The dynamic linker is passed the executable via a file
descriptor.</p><p>The file server uses its own filesystem object abstraction internally.
Filesystem objects may be files, directories or symbolic links on the
underlying filesystem provided by the Unix kernel.  They may also be
implemented entirely in the server.  The server has its own functions
for resolving pathnames and following symbolic links which do not use
the kernel's facility for following symbolic links.</p><p>The shell starts up a new server process for each command the user
enters.  The shell and the file server are linked into the same
executable and the shell uses the same filesystem object abstraction.
The shell simply uses fork() to start a new server.</p><p>User IDs are allocated by the setuid program
<span><strong class="command">run-as-anonymous</strong></span>.  It picks IDs in the range 0x100000 to
0x200000 (configurable by changing config.sh), and opens lock files in
the lock directory
<code class="filename">/usr/lib/plash-chroot-jail/plash-uid-locks</code> so that the
same UID is not allocated twice.  The lock directory goes inside the
chroot jail so that the sandboxed processes can also spawn processes
with reduced authority (though this is not done yet).  Therefore
`chroot-jail' needs to go on a writable filesystem, so you may need to
move it.</p><p>The setuid program <span><strong class="command">gc-uid-locks</strong></span> will garbage collect and
remove UID lock files for UIDs that are no longer in use.  It works by
scanning the `/proc' filesystem to list currently-running processes
and their UIDs.  When the shell starts, it runs
<span><strong class="command">gc-uid-locks</strong></span>.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="shell-scripts.html">Prev</a>&#160;</td><td width="20%" align="center">&#160;</td><td width="40%" align="right">&#160;<a accesskey="n" href="env-symlinks.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Shell scripts&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;Symbolic links</td></tr></table></div></body></html>
