<html><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968"><title>Examples</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Plash: the Principle of Least Authority shell"><link rel="up" href="exec-obj.html" title="Chapter&#160;4.&#160;Executable objects"><link rel="prev" href="exec-obj-legacy.html" title="Invocations between programs"><link rel="next" href="exec-obj-notes.html" title="Notes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Examples</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="exec-obj-legacy.html">Prev</a>&#160;</td><th width="60%" align="center">Chapter&#160;4.&#160;Executable objects</th><td width="20%" align="right">&#160;<a accesskey="n" href="exec-obj-notes.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exec-obj-examples"></a>Examples</h2></div></div></div><p>I'll look at creating an executable object for the Unix command line
program `oggenc', which encodes WAV files as Ogg Vorbis files.  (Ogg
Vorbis is like the MP3 format, but a bit smaller and free of patent
problems.)  To invoke `oggenc' with Plash you might do:</p><pre class="programlisting">
  oggenc input_file.wav =&gt; -o output_file.ogg
(1)</pre><p>In this case, the resulting process's file namespace will contain:
</p><div class="itemizedlist"><ul type="disc"><li><p>/usr/bin/oggenc (read-only)</p></li><li><p>/usr, /lib, /bin, /etc (read-only)</p></li><li><p>/dev/null (read-write)</p></li><li><p>under the pathname of the current working directory: input_file.wav (read-only), output_file.ogg (read-write slot)</p></li><li><p>/dev/tty (read-write)
</p></li></ul></div><p>However, it happens to be that `oggenc' doesn't need to access "/etc"
or all of "/usr".  We could define an executable object for running
`oggenc' that gives the program an execution environment containing
less:</p><pre class="programlisting">
  def my_oggenc =
    capcmd exec-object '/usr/bin/oggenc'
      /x=(mkfs /usr/bin/oggenc /usr/lib /lib)</pre><p>[This needs to be entered on one line when using the shell
interactively.  Alternatively, you can put it in a file and load it
with "source &lt;file&gt;" -- each command or declaration must be terminated
with ';'.]</p><p>This will create an executable object and bind it to the variable
"my_oggenc".  To invoke the object, we use the same syntax as before:</p><pre class="programlisting">
  my_oggenc input_file.wav =&gt; -o output_file.ogg
(2)</pre><p>In this case, the the resulting process's file namespace will contain:
</p><div class="itemizedlist"><ul type="disc"><li><p>/usr/bin/oggenc (read-only)</p></li><li><p>/usr/lib, /lib (read-only)</p></li><li><p>under the pathname of the current working directory:  input_file.wav (read-only), output_file.ogg (read-write slot)</p></li><li><p>/dev/tty (read-write)  [actually, not included in current version]</p></li></ul></div><p>While in (1), "oggenc" is treated as a filename and searched for in
PATH, in (2), "my_oggenc" is recognised by the shell as a bound
variable.  The shell doesn't start a new process in this case, it just
invokes the executable object that "my_oggenc" is bound to.  The shell
creates a namespace from the arguments, which it passes to
"my_oggenc", but it doesn't include "/usr", "/lib", "/bin" and "/etc"
as before -- the "my_oggenc" is expected to provide the files it
needs itself.</p><p>Suppose we don't want to install "oggenc" and the libraries it uses in
our system's "/usr" directory.  Maybe we don't have access to that
directory, because we don't have root access.  Maybe we have older
versions of those libraries in "/usr" which some other program uses,
and we don't want to risk messing that program up by upgrading its
libraries.  Maybe we just want to organise our files differently from
usual.  Perhaps we are running RedHat, but a Debian distribution is
installed under "/debian", and we want to use Debian's version of
`oggenc'.</p><pre class="programlisting">
  def my_oggenc =
    capcmd exec-object '/usr/bin/oggenc'
      /x=(mkfs
            /usr/bin/oggenc=(F /debian/usr/bin/oggenc)
            /usr/lib=(F /debian/usr/lib)
            /lib=(F /debian/lib))</pre><p>[NB. This requires that Plash is installed in the Debian distribution
as well, so that libc.so will still be taken from /usr/lib/plash/lib
rather than /lib.]</p><p>These declarations still give `oggenc' a lot of files it doesn't need.
We could give a tighter definition that lists exactly those files that
`oggenc' needs in its execution environment.  `oggenc' is fairly
simple: it doesn't use a huge number of dynamically-linked libraries,
and it doesn't need any configuration files.</p><p>Under Linux, we can find out the dynamic libraries that an executable
file uses with the "ldd" command:</p><pre class="programlisting">
  bash$ ldd /usr/bin/oggenc
	libvorbisenc.so.0 =&gt; /usr/lib/libvorbisenc.so.0 (0x40028000)
	libvorbis.so.0 =&gt; /usr/lib/libvorbis.so.0 (0x4009c000)
	libm.so.6 =&gt; /lib/i686/libm.so.6 (0x400bb000)
	libogg.so.0 =&gt; /usr/lib/libogg.so.0 (0x400dd000)
	libc.so.6 =&gt; /lib/i686/libc.so.6 (0x42000000)
	/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</pre><p>[Run this under Plash using "!!ldd /usr/bin/oggenc".]</p><p>Given this information, we can make a new definition:</p><pre class="programlisting">
  def my_oggenc =
    capcmd exec-object '/usr/bin/oggenc'
      /x=(mkfs
            /usr/bin/oggenc
            /usr/lib/libvorbisenc.so.0
            /usr/lib/libvorbis.so.0
            /lib/i686/libm.so.6
            /usr/lib/libogg.so.0
            /usr/lib/plash/lib/libc.so.6)</pre><p>[Future work will be to provide tools to help with constructing a
definition like this.]</p><p>("/lib/ld-linux.so.2" is the dynamic linker and doesn't need to be
included.)</p><p>Suppose we want another program to be able to invoke `my_oggenc'.  We
can attach the object into a filesystem with a syntax like this:</p><pre class="programlisting">
  bash + /my-bin/oggenc=my_oggenc</pre><p>[NB. I don't use `/bin/oggenc=my_oggenc' because it's not yet possible
to attach objects inside other attached directories, such as
`/bin/oggenc' inside `/bin', which is attached implicitly.]</p><p>This runs Bash with the pathname `/my-bin/oggenc' mapped to
`my_oggenc'.  You can then run `my_oggenc' from inside Bash.  This is
a good way in general to test out the file namespaces that Plash
creates.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="exec-obj-legacy.html">Prev</a>&#160;</td><td width="20%" align="center"><a accesskey="u" href="exec-obj.html">Up</a></td><td width="40%" align="right">&#160;<a accesskey="n" href="exec-obj-notes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Invocations between programs&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;Notes</td></tr></table></div></body></html>
