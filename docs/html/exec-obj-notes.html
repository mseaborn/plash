<html><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968"><title>Notes</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Plash: the Principle of Least Authority shell"><link rel="up" href="exec-obj.html" title="Chapter&#160;4.&#160;Executable objects"><link rel="prev" href="exec-obj-examples.html" title="Examples"><link rel="next" href="exec-obj-limits.html" title="Limitations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Notes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="exec-obj-examples.html">Prev</a>&#160;</td><th width="60%" align="center">Chapter&#160;4.&#160;Executable objects</th><td width="20%" align="right">&#160;<a accesskey="n" href="exec-obj-limits.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exec-obj-notes"></a>Notes</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2522850"></a>The process replacement behaviour</h3></div></div></div><p>Normally, execve() replaces the current process.  Method calls don't
and can't have that behaviour: the callee does not even have to start
a new process.</p><p>The modified libc is responsible for emulating the process replacement
behaviour.  execve() (and the other functions in the `exec' family
which use it) will test whether the filename it is given resolves to
an executable object or a regular file.  This test uses the "Exep"
method.  Note that this is different to the shell: the shell chooses
its behaviour according to whether the command name is a bound
variable or not.</p><p>If execve() is given an executable object, it invokes it (passing the
root directory, file descriptors, etc.).  When the method call
returns, this means the new process has exited; it gives the exit
code.  libc's execve() wait for the method call to return, and then
exits, using the same exit code.</p><p>Plash does not modify libc's wait() and waitpid().</p><p>This is slightly unsatisfactory in three respects:</p><div class="itemizedlist"><ul type="disc"><li><p>It doesn't let P return the correct wait() status code to its
   parent when the process created by X dies with an unhandled signal
   (such as SIGSEGV).</p></li><li><p>It doesn't let P notify its parent when the new process is stopped
   (by SIGSTOP or when the user presses Ctrl-Z).</p></li><li><p>kill() doesn't work as expected:  it sends a signal to the process
   that is waiting, not the process it spawned.</p></li><li><p>There is an extra process hanging around, filling up the process
   table and taking up memory (and holding onto open file descriptors
   -- though this could be fixed) but not doing much else.
</p></li></ul></div><p>The solution to this would be to modify wait() and waitpid().  This
would not be too bad because they can only be used on child processes.
Modifying kill() as well would be trickier and less desirable, because
it involves a global namespace of process IDs, and we would like to
avoid global namespaces.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2522926"></a>Discovering file descriptors</h3></div></div></div><p>libc's execve() finds out which file descriptor indexes a process has
open simply by trying to dup() each index in turn, upto a high index
number.  If your program uses FDs with big FD numbers (eg. &gt;1000),
this may cause problems.  Although the Linux `proc' filesystem can be
used to find out what file descriptors a process has open, this is not
available in the Linux chroot() environment Plash uses to run programs
in, and there's no way to use it securely.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2522957"></a>Garbage collection</h3></div></div></div><p>exec-object will exit when the reference to the object it provides is
dropped, and it has no more processes to handle.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="exec-obj-examples.html">Prev</a>&#160;</td><td width="20%" align="center"><a accesskey="u" href="exec-obj.html">Up</a></td><td width="40%" align="right">&#160;<a accesskey="n" href="exec-obj-limits.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Examples&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;Limitations</td></tr></table></div></body></html>
