<html><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968"><title>fs_op object</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Plash: the Principle of Least Authority shell"><link rel="up" href="interfaces.html" title="Chapter&#160;5.&#160;Protocols and interfaces"><link rel="prev" href="env-vars.html" title="PLASH_COMM_FD and PLASH_CAPS"><link rel="next" href="obj-fsobj.html" title="Filesystem objects: files, directories and symlinks"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">fs_op object</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="env-vars.html">Prev</a>&#160;</td><th width="60%" align="center">Chapter&#160;5.&#160;Protocols and interfaces</th><td width="20%" align="right">&#160;<a accesskey="n" href="obj-fsobj.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="obj-fs-op"></a>fs_op object</h2></div></div></div><p>This object implements all the standard Unix filesystem calls that
operate on pathnames:  open(), mkdir(), unlink() and so on.  You can
construct one of these objects given a root directory.</p><p>This object has one piece of state: the current working directory
(cwd).  This is allowed to be unset, in which case any operation that
it relative to the cwd will return an error.</p><p>Notation:
</p><div class="itemizedlist"><ul type="disc"><li><p>The request is given before "=&gt;"; possible replies come after.</p></li><li><p>"+ FD" indicates that a message includes a file descriptor argument.</p></li><li><p>"+ foo/obj" indicates that a message includes an object reference.</p></li></ul></div><p>Methods:</p><pre class="programlisting">// duplicate the connection -- called before the fork() syscall
// (now obsolete; will be removed)
"Fork"
=&gt;
"RFrk" + FD

"Copy"
=&gt; "Okay" + fs_op/obj

"Gdir" pathname
=&gt; "Okay" + dir/obj
Resolves `pathname' to get a directory, and returns the directory object.

"Grtd"
=&gt; "Okay" + dir/obj
Same as &lt;&lt;"Gdir" "/"&gt;&gt;.

"Gobj" pathname
=&gt; "Okay" + obj
Resolved `pathname' to get any object; will follow symlinks.

// open() call
"Open" flags/int mode/int filename
=&gt;
"ROpn" + FD
"RDfd" + FD + dir_stack/obj // This is returned when open() is used on a directory.
                            // FD is for /dev/null, and the object is a dir_stack.
"Fail" errno/int

// stat() and lstat() calls
"Stat" nofollow/int pathname
=&gt;
"RSta" stat
"Fail" errno/int

// readlink() call
"Rdlk" pathname
=&gt;
"RRdl" string
"Fail" errno/int

// chdir() call
"Chdr" pathname
=&gt;
"RSuc"
"Fail" errno/int

// fchdir() call:  takes a dir_stack object as returned by open()
"Fchd" + dir_stack/obj
=&gt;
"Okay"
"Fail" errno/int

// getcwd() call
"Gcwd"
=&gt;
"RCwd" pathname
"Fail" errno/int

// list contents of directories: opendir() + readdir() + closedir()
"Dlst" pathname
=&gt;
// same as `struct dirent' format:
"RDls" (inode/int type/int name_size/int name)*
"Fail" errno/int

// access() call
"Accs" mode/int pathname
=&gt;
"RAcc"
"Fail" errno/int

// mkdir()
"Mkdr" mode/int pathname
=&gt;
"RMkd"
"Fail" errno/int

// chmod() call
"Chmd" mode/int pathname
=&gt;
"RChm"
"Fail" errno/int

// utime()/utimes()/lutimes() calls
"Utim" nofollow/int
	atime_sec/int atime_usec/int
	mtime_sec/int mtime_usec/int
	pathname
=&gt;
"RUtm"
"Fail" errno/int

// rename() call
"Renm" newpath-length/int newpath oldpath
=&gt;
"RRnm"
"Fail" errno/int

// link() call
"Link" newpath-length/int newpath oldpath
=&gt;
"RLnk"
"Fail" errno/int

// symlink() call
"Syml" newpath-length/int newpath oldpath
=&gt;
"RSym"
"Fail" errno/int

// unlink() call
"Unlk" pathname
=&gt;
"RUnl"
"Fail" errno/int

// rmdir() call
"Rmdr" pathname
=&gt;
"RRmd"
"Fail" errno/int

// connect() on Unix domain sockets
"Fcon" pathname + FD
=&gt;
"RFco"
"Fail" errno/int

// bind() on Unix domain sockets
"Fbnd" pathname + FD
=&gt;
"RFbd"
"Fail" errno/int

// part of execve() call
// The RExe result tells the client what it should pass to the exec syscall.
// The client allocates a spare FD slot; it tells the server the number.
// The server can then use this FD number in the arguments it returns.
// The client receives an FD; it must copy it into that slot using "dup2".
// This will be extended so that the server can also carry out the work of
// the new process.
// The RExo result returns an executable object which the client must invoke
// with full arguments, including the root directory.
"Exec" fd-number/int cmd-len/int cmd argc/int (arg-len/int arg)*
=&gt;
"RExe" cmd-len/int cmd argc/int (arg-len/int arg)* + FD
"RExo" + CAP
"Fail" errno/int


where:

stat = dev ino mode nlink uid gid rdev size blksize blocks atime mtime ctime
       (all ints)

</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="env-vars.html">Prev</a>&#160;</td><td width="20%" align="center"><a accesskey="u" href="interfaces.html">Up</a></td><td width="40%" align="right">&#160;<a accesskey="n" href="obj-fsobj.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><code class="envar">PLASH_COMM_FD</code> and <code class="envar">PLASH_CAPS</code>&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;Filesystem objects: files, directories and symlinks</td></tr></table></div></body></html>
