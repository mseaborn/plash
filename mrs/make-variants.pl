#!/usr/bin/perl -w

# A variant such as
#   al_cat: arglist, arglist
# generates
#   struct arg_list { int variant; };
#   struct arg_list_al_cat {
#     int variant;
#     struct arg_list *a1;
#     struct arg_list *a2;
#   };
#   struct arg_list *mk_al_cat(region_t r, struct arg_list *a1, struct arg_list *a2)
#   {
#     struct arg_list_al_cat *n = amalloc(sizeof(struct arg_list_al_cat));
#     n->variant = 1;
#     n->a1 = a1;
#     n->a2 = a2;
#     return (struct arg_list *) n;
#   }
#   int m_al_cat(struct arg_list *in, struct arg_list **out1, struct arg_list **out2)
#   {
#     if(in->variant == 1) {
#       struct arg_list_al_cat *x = (void *) in;
#       *out1 = n->a1;
#       *out2 = n->a2;
#       return 1;
#     }
#     else return 0;
#   }


use IO::File;

local $count = 1;


my $defs =
[
  { Name => 'arg_list',
    Variants =>
      [['arg_empty', []],
       ['arg_cat', ['a1 arg_list', 'a2 arg_list']],
       ['arg_read', ['a arg_list']],
       ['arg_write', ['a arg_list']],
       ['arg_ambient', ['f arg_list']],
       ['arg_string', ['s char_cons']],
       ['arg_filename', ['f char_cons']],
      ]
  },
  { Name => 'file_list',
    Variants => []
  },
  { Name => 'command',
    Variants =>
      [['command', ['c char_cons', 'a arg_list']],
       ['chdir', ['f char_cons']],
      ]
  },
];

my $banner =
  "/* This file was automatically generated by gen-variants.pl. */\n\n";

my $out_main = IO::File->new('mrs/shell-variants.c', O_CREAT | O_WRONLY | O_TRUNC);
if(!defined $out_main) { die }
print $out_main $banner;
print $out_main "#include \"shell-variants.h\"\n\n";
foreach my $def (@$defs) { gen($out_main, $def); }

my $out_hdr = IO::File->new('mrs/shell-variants.h', O_CREAT | O_WRONLY | O_TRUNC);
if(!defined $out_hdr) { die }
print $out_hdr $banner;
print $out_hdr "#include \"region.h\"\n";
print $out_hdr "#include \"shell.h\"\n";
foreach my $desc (@$defs) {
  print $out_hdr "struct $desc->{Name};\n";
}
foreach my $def (@$defs) { gen_header($out_hdr, $def); }


sub process_args {
  my ($v) = @_;
  my @args;
  foreach my $arg (@{$v->[1]}) {
    my $name;
    my $type;
    if($arg =~ /^(\S+)\s+T\s+/) {
      $name = $1;
      $type = "$' ";
    }
    elsif($arg =~ /^(\S+)\s+(\S+)$/) {
      $name = $1;
      $type = "struct $2 *";
    }
    else { die "Bad: $v" }
    push(@args, { Name => $name, Type => $type });
  }
  \@args
}

sub gen_header {
  my ($out, $desc) = @_;

  foreach my $v (@{$desc->{Variants}}) {
    my $v_name = $v->[0];
    my $args = process_args($v);
    
    print $out "struct $desc->{Name} *mk_$v_name(region_t r".
      join('', map { ", $_->{Type}$_->{Name}" } @$args).");\n";
    
    print $out "int m_$v_name(struct $desc->{Name} *in_obj".
      join('', map { ", $_->{Type}*out_$_->{Name}" } @$args).");\n";
  }
}

sub gen {
  my ($out, $desc) = @_;

  print $out "struct $desc->{Name} { int variant; };\n";
  my $type_code = $count++;
  my $min_code = $type_code * 1000;
  my $max_code = $type_code * 1000 + scalar(@{$desc->{Variants}});
  my $v_number = $min_code;

  foreach my $v (@{$desc->{Variants}}) {
    my $v_name = $v->[0];
    my $args = process_args($v);

    print $out "\n";
    
    print $out "struct $desc->{Name}_$v_name {\n";
    print $out "  int variant;\n";
    foreach my $n (@$args) { print $out "  $n->{Type}$n->{Name};\n"; }
    print $out "};\n";

    print $out "struct $desc->{Name} *mk_$v_name(region_t r".
      join('', map { ", $_->{Type}$_->{Name}" } @$args).")\n";
    print $out "{\n";
    print $out "  struct $desc->{Name}_$v_name *new_obj = ".
      "region_alloc(r, sizeof(struct $desc->{Name}_$v_name));\n";
    print $out "  new_obj->variant = $v_number;\n";
    foreach my $n (@$args) { print $out "  new_obj->$n->{Name} = $n->{Name};\n"; }
    print $out "  return (struct $desc->{Name} *) new_obj;\n";
    print $out "}\n";

    print $out "int m_$v_name(struct $desc->{Name} *in_obj".
      join('', map { ", $_->{Type}*out_$_->{Name}" } @$args).")\n";
    print $out "{\n";
    print $out "  assert(in_obj);\n";
    print $out "  assert($min_code <= in_obj->variant && in_obj->variant < $max_code);\n";
    print $out "  if(in_obj->variant == $v_number) {\n";
    print $out "    struct $desc->{Name}_$v_name *x = (void *) in_obj;\n";
    foreach my $n (@$args) { print $out "    *out_$n->{Name} = x->$n->{Name};\n"; }
    print $out "    return 1;\n";
    print $out "  }\n";
    print $out "  else return 0;\n";
    print $out "}\n";
    
    $v_number++;
  }
}
