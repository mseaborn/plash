#!/usr/bin/python

# Copyright (C) 2006, 2007 Mark Seaborn
#
# This file is part of Plash.
#
# Plash is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# Plash is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with Plash; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,
# USA.

"""
Usage: plash-pkg-deb-inst <app-dir>

Run preinst and postinst scripts for Debian packages.
"""

import gobject
import os
import sys

import plash_core
import plash.namespace as ns
import plash.mainloop
import plash.process

import plash_pkg.config
import plash_pkg.control
import plash_pkg.launch
import plash_pkg.unpack


cwd = os.getcwd()
def restore_cwd_hack():
    os.chdir(cwd)


STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2


class InteractiveMode(object):

    def __init__(self, proc, setup):
        self._fd_forwarders = setup.grant_proxy_terminal_access()

    def finished(self):
        for forwarder in self._fd_forwarders:
            forwarder.flush()


class NoninteractiveMode(object):

    def __init__(self, proc, setup):
        output_fd, self._forwarder = \
            plash.filedesc.proxy_output_fd(os.dup(STDOUT_FILENO))
        proc.fds[STDIN_FILENO] = \
            plash_core.wrap_fd(os.open("/dev/null", os.O_WRONLY))
        proc.fds[STDOUT_FILENO] = output_fd
        proc.fds[STDERR_FILENO] = output_fd

    def finished(self):
        self._forwarder.flush()


def init_package(unpack_cache, app_dir, pkg, control_script, args):
    my_root = plash_pkg.launch.FileNamespace()
    restore_cwd_hack()
    proc, setup = plash_pkg.launch.make_process(app_dir)

    unpack_dir = unpack_cache.get_unpacked(pkg)
    script_path = os.path.join(unpack_dir, "control", control_script)

    restore_cwd_hack()
    if os.path.exists(script_path):
        sys.stdout.write("-- %s_%s %s\n" %
                         (pkg["package"], pkg["version"], control_script))
        sys.stdout.flush()
        proc.get_namespace().attach_at_path("/script",
                                            my_root.get_obj(script_path))
        proc.cmd = "/script"
        proc.args = args
        helper = NoninteractiveMode(proc, setup)
        pid = proc.spawn()
        reason_to_run = plash.mainloop.ReasonToRun()
        def child_exit_callback(pid_unused, status):
            reason_to_run.dispose()
            helper.finished()
        gobject.child_watch_add(pid, child_exit_callback)
        # TODO: give error if process's exit status is non-zero
        # TODO: ensure we stop running server when child process exits
        plash.mainloop.run_server()

def init_packages(unpack_cache, app_dir):
    fh = open(os.path.join(app_dir, "package-list"), "r")
    try:
        for block in plash_pkg.control.file_blocks(fh):
            pkg = plash_pkg.control.block_fields(block)
            init_package(unpack_cache, app_dir, pkg, "preinst", ["install"])
            init_package(unpack_cache, app_dir, pkg, "postinst", ["configure"])
    finally:
        fh.close()

def main(args):
    if len(args) != 1:
        print __doc__
        return 1
    app_dir = args[0]
    unpack_cache = plash_pkg.unpack.UnpackCache(None)
    init_packages(unpack_cache, app_dir)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
