#!/usr/bin/python

# Copyright (C) 2006, 2007 Mark Seaborn
#
# This file is part of Plash.
#
# Plash is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# Plash is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with Plash; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,
# USA.

"""
Usage: plash-pkg-deb-inst <app-dir>

Run preinst and postinst scripts for Debian packages.
"""

import gobject
import os
import sys

import plash.namespace as ns
import plash.mainloop
import plash.process

import plash_pkg.config
import plash_pkg.control
import plash_pkg.launch
import plash_pkg.unpack


cwd = os.getcwd()
def restore_cwd_hack():
    os.chdir(cwd)


def init_package(unpack_cache, app_dir, pkg, control_script, args):
    my_root = plash_pkg.launch.FileNamespace()
    restore_cwd_hack()
    proc, setup = plash_pkg.launch.make_process(app_dir)

    unpack_dir = unpack_cache.get_unpacked(pkg)
    script_path = os.path.join(unpack_dir, "control", control_script)

    restore_cwd_hack()
    if os.path.exists(script_path):
        ns.attach_at_path(proc.root_node, "/script",
                          my_root.get_obj(script_path))
        proc.cmd = "/script"
        proc.args = args
        fd_forwarders = setup.grant_proxy_terminal_access()
        pid = proc.spawn()
        reason_to_run = plash.mainloop.ReasonToRun()
        def child_exit_callback(pid_unused, status):
            reason_to_run.dispose()
            for forwarder in fd_forwarders:
                forwarder.flush()
        gobject.child_watch_add(pid, child_exit_callback)
        # TODO: give error if process's exit status is non-zero
        # TODO: ensure we stop running server when child process exits
        plash.mainloop.run_server()
    else:
        print "  no %s" % control_script

def init_packages(unpack_cache, app_dir):
    fh = open(os.path.join(app_dir, "package-list"), "r")
    try:
        for block in plash_pkg.control.file_blocks(fh):
            pkg = plash_pkg.control.block_fields(block)
            print "%s_%s" % (pkg["package"], pkg["version"])
            init_package(unpack_cache, app_dir, pkg, "preinst", ["install"])
            init_package(unpack_cache, app_dir, pkg, "postinst", ["configure"])
    finally:
        fh.close()

def main(args):
    if len(args) != 1:
        print __doc__
        return 1
    app_dir = args[0]
    unpack_cache = plash_pkg.unpack.UnpackCache(None)
    init_packages(unpack_cache, app_dir)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
