#!/usr/bin/python

"""
Usage:
plash-pkg-install <package_dir> --init <package-spec-file>
plash-pkg-install <package_dir> --get
plash-pkg-install <package_dir> --inst
"""

import os
import pwd
import subprocess
import sys

import plash_pkg.config
import plash_pkg.control
import plash_pkg.utils


def read_config_file(filename):
    fh = file(filename, "r")
    try:
        blocks = list(plash_pkg.control.file_blocks(fh))
    finally:
        fh.close()
    assert len(blocks) == 1
    return plash_pkg.control.block_fields(blocks[0])

def strip_root(filename):
    """Remove the initial slashes from a pathname, turning it into a
    relative pathname."""
    return filename.lstrip("/")

def look_up_in_path(name):
    """Look up an executable name in PATH."""
    for dir_path in os.environ["PATH"].split(":"):
        filename = os.path.join(dir_path, name)
        if os.path.exists(filename):
            return filename
    raise Exception("Executable not found in PATH: %s" % name)

def run_cmd(*args):
    rc = subprocess.call(args)
    if rc != 0:
        raise Exception("Command failed with code %i: %s"
                        % (rc, " ".join(args)))


class AppDir(object):

    def __init__(self, dir):
        self.dir = dir
        self.config = read_config_file(os.path.join(dir, "config"))

    def choose_and_unpack(self):
        run_cmd("plash-pkg-choose", self.dir, self.config["depends"])
        run_cmd("plash-pkg-fetch", os.path.join(self.dir, "package-list"))
        # Delete any existing unpacked tree
        unpack_dir = os.path.join(self.dir, "unpacked")
        if os.path.exists(unpack_dir):
            run_cmd("rm", "-rf", unpack_dir)
        run_cmd("plash-pkg-unpack",
                os.path.join(self.dir, "package-list"),
                unpack_dir)

    def init_write_layer(self):
        dest = os.path.join(self.dir, "write_layer")
        if not os.path.exists(dest):
            os.mkdir(dest)

            uid = os.getuid()
            try:
                pw_ent = pwd.getpwuid(uid)
            except KeyError:
                print "Warning: No passwd entry found for uid %i" % uid
            else:
                home_dir = pw_ent.pw_dir
                os.mkdir(os.path.join(dest, "etc"))
                plash_pkg.utils.write_file(os.path.join(dest, "etc", "passwd"),
                                     "%s:x:%i:%i::%s:/bin/false\n"
                                     % (pw_ent.pw_name, uid, uid, home_dir))
                os.makedirs(os.path.join(dest, strip_root(home_dir)))

    def desktop_file(self):
        fields = []
        fields.append(("Encoding", "UTF-8"))
        fields.append(("Type", "Application"))
        fields.append(("Terminal", "false"))
        fields.append(("Name", self.config["pet-name"]))
        if "mimetype" in self.config:
            fields.append(("MimeType", self.config["mimetype"]))
        if "icon" in self.config:
            fields.append(("Icon", self.config["icon"]))
        
        launcher = os.path.abspath(look_up_in_path("plash-pkg-launch"))
        abs_app_dir = os.path.abspath(self.dir)
        # FIXME: should quote unusual chars in substituted strings
        fields.append(("Exec",
                       " ".join([launcher,
                                 "--app-dir", abs_app_dir,
                                 "--open-files", "%f"])))
        fields.append(("Categories", "SandboxedApps"))

        for key, value in fields:
            assert "\n" not in value, "Field contains newline: %s" % value
        return "".join(["[Desktop Entry]\n"] +
                       ["%s=%s\n" % (key, value)
                        for key, value in fields])


def main(args):
    if len(args) < 2:
        print __doc__
        return 1
    output_dir = args.pop(0)
    action = args.pop(0)
    
    if action == "--init" and len(args) == 1:
        config_file = args[0]
        if not os.path.exists(output_dir):
            os.mkdir(output_dir)
        plash_pkg.utils.write_file(os.path.join(output_dir, "config"),
                             plash_pkg.utils.read_file(config_file))
    elif action == "--get" and len(args) == 0:
        app = AppDir(output_dir)
        app.choose_and_unpack()
        app.init_write_layer()
    elif action == "--inst" and len(args) == 0:
        app = AppDir(output_dir)
        plash_pkg.utils.write_file(
            os.path.join(plash_pkg.config.get_desktop_files_dir(),
                         "plash-%s.desktop"
                         % app.config["pet-id"]),
            app.desktop_file())
    else:
        print __doc__
        return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
