#!/usr/bin/python

"""
Usage: plash-pkg-unpack <package-list> <dest-dir>

Unpacks the packages listed in <package-list> into <dest-dir>.
Re-uses/shares file inodes by hard linking them from a cache
directory.
"""

import os
import re
import sha
import subprocess
import sys

import plash_pkg.config
import plash_pkg.control


verbose = True

def read_control_file(filename):
    fh = open(filename, "r")
    try:
        return [plash_pkg.control.block_fields(b)
                for b in plash_pkg.control.file_blocks(fh)]
    finally:
        fh.close()

def sha_of_file(filename):
    digest = sha.new()
    fh = open(filename, "r")
    try:
        while True:
            data = fh.read(4096)
            if len(data) == 0:
                break
            digest.update(data)
        return digest
    finally:
        fh.close()

def unpack_into_cache(unpack_cache, pkg):
    if "filelist-ref" in pkg:
        return
    
    match = re.search("/([^/]+)$", pkg["filename"])
    assert match is not None
    leafname = match.group(1)
    deb_file = os.path.join(plash_pkg.config.get_deb_cache_dir(), leafname)
    if not os.path.exists(deb_file):
        raise Exception("File not present: %s" % deb_file)

    if "sha1" not in pkg:
        raise Exception("Package %(package)s %(version)s lacks a SHA1 field"
                        % pkg)

    out_dir = os.path.join(unpack_cache,
                           "%(package)s_%(version)s" % pkg)
    if not os.path.exists(out_dir):
        os.mkdir(out_dir)

    dest_data = os.path.join(out_dir, "data")
    dest_control = os.path.join(out_dir, "control")
    extract_data = not os.path.exists(dest_data)
    extract_control = not os.path.exists(dest_control)

    # Check hash.  The contents of the file will be in the cache for
    # when we unpack the .deb afterwards.
    if extract_data or extract_control:
        hash_expect = pkg["sha1"]
        hash_got = sha_of_file(deb_file).hexdigest()
        if hash_expect != hash_got:
            raise Exception("Hashes do not match on file: %s" % deb_file)
    
    # Extract main files -- data.tar.gz from the .deb
    if extract_data:
        print "unpack", dest_data
        dest_data_tmp = "%s.tmp" % dest_data
        if os.path.exists(dest_data_tmp):
            raise Exception("Remove %s and try again" % dest_data_tmp)
        rc = subprocess.call(["dpkg-deb", "-x", deb_file, dest_data_tmp])
        assert rc == 0
        os.rename(dest_data_tmp, dest_data)

    # Extract control files -- control.tar.gz from the .deb
    if extract_control:
        print "unpack", dest_control
        dest_control_tmp = "%s.tmp" % dest_control
        if os.path.exists(dest_control_tmp):
            raise Exception("Remove %s and try again" % dest_control_tmp)
        rc = subprocess.call(["dpkg-deb", "-e", deb_file, dest_control_tmp])
        assert rc == 0
        os.rename(dest_control_tmp, dest_control)

def unpack_file_list(dest_dir, hash_dir, ref):
    fh = open(os.path.join(hash_dir, ref), "r")
    for line in fh:
        line = line.rstrip("\n")
        if line != "":
            file_hash, dest_path = line.split("\t", 1)
            # don't unpack into root!  remove this later...
            dest_path = dest_path.lstrip("/")
            mkdir_p(os.path.join(dest_dir,
                                 os.path.dirname(dest_path)))
            os.link(os.path.join(hash_dir, file_hash),
                    os.path.join(dest_dir, dest_path))

def unpack_to_single_dir(unpack_cache, dest_dir, pkg):
    if "filelist-ref" in pkg:
        unpack_file_list(dest_dir,
                         os.path.join(unpack_cache, "files"),
                         pkg["filelist-ref"])
    else:
        src = os.path.join(unpack_cache,
                           "%(package)s_%(version)s" % pkg,
                           "data")
        for leaf in os.listdir(src):
            rc = subprocess.call(["cp", "-lr", os.path.join(src, leaf),
                                  dest_dir])
            assert rc == 0

def mkdir_p(dir_path):
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

def fill_out_dpkg_status(dest_dir, packages):
    dpkg_dir = os.path.join(dest_dir, "var", "lib", "dpkg")
    mkdir_p(dpkg_dir)
    fh = open(os.path.join(dpkg_dir, "status"), "w")
    try:
        for pkg in packages:
            fh.write("Package: %(package)s\n"
                     "Version: %(version)s\n"
                     "Status: install ok installed\n\n"
                     % pkg)
    finally:
        fh.close()

def main(args):
    if len(args) != 2:
        print __doc__
        sys.exit(1)
    package_list = args[0]
    dest_dir = args[1]
    unpack_cache = plash_pkg.config.get_unpack_cache_dir()
    packages = read_control_file(package_list)
    for pkg in packages:
        unpack_into_cache(unpack_cache, pkg)
    os.mkdir(dest_dir)
    for pkg in packages:
        unpack_to_single_dir(unpack_cache, dest_dir, pkg)
    fill_out_dpkg_status(dest_dir, packages)


if __name__ == "__main__":
    main(sys.argv[1:])
